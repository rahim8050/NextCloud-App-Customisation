{"version":3,"file":"memories-vendors-node_modules_webworker-typed_dist_index_js-node_modules_workbox-expiration_index_mjs.js?v=d19c857e832ee4832a08","mappings":"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","sources":["webpack:///memories/node_modules/workbox-expiration/_version.js","webpack:///memories/node_modules/workbox-core/_version.js","webpack:///memories/node_modules/webworker-typed/dist/index.js","webpack:///memories/node_modules/workbox-core/_private/WorkboxError.js","webpack:///memories/node_modules/idb/build/wrap-idb-value.js","webpack:///memories/node_modules/idb/build/index.js","webpack:///memories/node_modules/workbox-expiration/models/CacheTimestampsModel.js","webpack:///memories/node_modules/workbox-expiration/CacheExpiration.js","webpack:///memories/node_modules/workbox-core/_private/dontWaitFor.js","webpack:///memories/node_modules/workbox-core/_private/cacheNames.js","webpack:///memories/node_modules/workbox-core/models/quotaErrorCallbacks.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:expiration:7.2.0'] && _();\n}\ncatch (e) { }\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:7.2.0'] && _();\n}\ncatch (e) { }\n","/**\n * Export methods from a worker to the main thread.\n *\n * @param handlers Object with methods to export\n *\n * @example\n * ```ts\n * // my-worker.ts\n * function foo() { return 'bar'; }\n *\n * async function asyncFoo() { return 'bar'; }\n *\n * export default exportWorker({\n *   foo,\n *   asyncFoo,\n *   inline: () => 'bar',\n * });\n * ```\n */\nexport function exportWorker(handlers) {\n    self.onmessage = async ({ data }) => {\n        try {\n            // Get handler from registrations\n            const handler = handlers[data.name];\n            if (!handler)\n                throw new Error(`[BUG] No handler for type ${data.name}`);\n            // Run handler\n            let result = handler.apply(self, data.args);\n            if (result instanceof Promise) {\n                result = await result;\n            }\n            // Success - post back to main thread\n            self.postMessage({ reqid: data.reqid, resolve: result });\n        }\n        catch (e) {\n            // Error - post back rejection\n            self.postMessage({ reqid: data.reqid, reject: e.message });\n        }\n    };\n    return null;\n}\n/**\n * Import a worker exported with `exportWorker`.\n *\n * @param worker Worker to import\n *\n * @example\n * ```ts\n * // main.ts\n * import type MyWorker from './my-worker.ts';\n *\n * const worker = importWorker<typeof MyWorker>(new Worker(new URL('./XImgWorkerStub.ts', import.meta.url)));\n *\n * (async () => {\n *   // all methods are async\n *   console.assert(await worker.foo() === 'bar');\n *   console.assert(await worker.asyncFoo() === 'bar');\n *   console.assert(await worker.inline() === 'bar');\n * })();\n * ```\n */\nexport function importWorker(worker) {\n    const promises = new Map();\n    // Handle messages from worker\n    worker.onmessage = ({ data }) => {\n        var _a, _b;\n        const { reqid, resolve, reject } = data;\n        if (resolve)\n            (_a = promises.get(reqid)) === null || _a === void 0 ? void 0 : _a.resolve(resolve);\n        if (reject)\n            (_b = promises.get(reqid)) === null || _b === void 0 ? void 0 : _b.reject(reject);\n        promises.delete(reqid);\n    };\n    // Create proxy to call worker methods\n    const proxy = new Proxy(worker, {\n        get(target, name) {\n            return async function wrapper(...args) {\n                return await new Promise((resolve, reject) => {\n                    const reqid = Math.random();\n                    promises.set(reqid, { resolve, reject });\n                    target.postMessage({ reqid, name, args }, {\n                        transfer: args.filter(isTransferred)\n                    });\n                });\n            };\n        },\n    });\n    return proxy;\n}\n// Key to mark an object as transferred\nconst TRANSFERRED_KEY = \"_wwt_is_transferred_\";\n/**\n * Mark an object as transferred.\n *\n * @param object Object to transfer\n *\n * @example\n * ```ts\n * // main.ts\n * worker.foo(transfer(new ArrayBuffer(1000)));\n */\nexport function transfer(object) {\n    if (typeof object === 'object') {\n        object[TRANSFERRED_KEY] = true;\n        return object;\n    }\n    throw new Error('Only objects can be transferred');\n}\n/**\n * Check if an object is transferred.\n */\nfunction isTransferred(object) {\n    return typeof object === 'object' && object[TRANSFERRED_KEY] === true;\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messageGenerator } from '../models/messages/messageGenerator.js';\nimport '../_version.js';\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n    /**\n     *\n     * @param {string} errorCode The error code that\n     * identifies this particular error.\n     * @param {Object=} details Any relevant arguments\n     * that will help developers identify issues should\n     * be added as a key on the context object.\n     */\n    constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\nexport { WorkboxError };\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { openDB, deleteDB } from 'idb';\nimport '../_version.js';\nconst DB_NAME = 'workbox-expiration';\nconst CACHE_OBJECT_STORE = 'cache-entries';\nconst normalizeURL = (unNormalizedUrl) => {\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = '';\n    return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n    /**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */\n    constructor(cacheName) {\n        this._db = null;\n        this._cacheName = cacheName;\n    }\n    /**\n     * Performs an upgrade of indexedDB.\n     *\n     * @param {IDBPDatabase<CacheDbSchema>} db\n     *\n     * @private\n     */\n    _upgradeDb(db) {\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, { keyPath: 'id' });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', { unique: false });\n        objStore.createIndex('timestamp', 'timestamp', { unique: false });\n    }\n    /**\n     * Performs an upgrade of indexedDB and deletes deprecated DBs.\n     *\n     * @param {IDBPDatabase<CacheDbSchema>} db\n     *\n     * @private\n     */\n    _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n            void deleteDB(this._cacheName);\n        }\n    }\n    /**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            url,\n            timestamp,\n            cacheName: this._cacheName,\n            // Creating an ID from the URL and cache name won't be necessary once\n            // Edge switches to Chromium and all browsers we support work with\n            // array keyPaths.\n            id: this._getId(url),\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n            durability: 'relaxed',\n        });\n        await tx.store.put(entry);\n        await tx.done;\n    }\n    /**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number | undefined}\n     *\n     * @private\n     */\n    async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n    }\n    /**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     * @return {Array<string>}\n     *\n     * @private\n     */\n    async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db\n            .transaction(CACHE_OBJECT_STORE)\n            .store.index('timestamp')\n            .openCursor(null, 'prev');\n        const entriesToDelete = [];\n        let entriesNotDeletedCount = 0;\n        while (cursor) {\n            const result = cursor.value;\n            // TODO(philipwalton): once we can use a multi-key index, we\n            // won't have to check `cacheName` here.\n            if (result.cacheName === this._cacheName) {\n                // Delete an entry if it's older than the max age or\n                // if we already have the max number allowed.\n                if ((minTimestamp && result.timestamp < minTimestamp) ||\n                    (maxCount && entriesNotDeletedCount >= maxCount)) {\n                    // TODO(philipwalton): we should be able to delete the\n                    // entry right here, but doing so causes an iteration\n                    // bug in Safari stable (fixed in TP). Instead we can\n                    // store the keys of the entries to delete, and then\n                    // delete the separate transactions.\n                    // https://github.com/GoogleChrome/workbox/issues/1978\n                    // cursor.delete();\n                    // We only need to return the URL, not the whole entry.\n                    entriesToDelete.push(cursor.value);\n                }\n                else {\n                    entriesNotDeletedCount++;\n                }\n            }\n            cursor = await cursor.continue();\n        }\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n            await db.delete(CACHE_OBJECT_STORE, entry.id);\n            urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n    }\n    /**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     *\n     * @private\n     */\n    _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n    }\n    /**\n     * Returns an open connection to the database.\n     *\n     * @private\n     */\n    async getDb() {\n        if (!this._db) {\n            this._db = await openDB(DB_NAME, 1, {\n                upgrade: this._upgradeDbAndDeleteOldDbs.bind(this),\n            });\n        }\n        return this._db;\n    }\n}\nexport { CacheTimestampsModel };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds\n            ? Date.now() - this._maxAgeSeconds * 1000\n            : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url, this._matchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n            return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    void promise.then(() => { });\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst _cacheNameDetails = {\n    googleAnalytics: 'googleAnalytics',\n    precache: 'precache-v2',\n    prefix: 'workbox',\n    runtime: 'runtime',\n    suffix: typeof registration !== 'undefined' ? registration.scope : '',\n};\nconst _createCacheName = (cacheName) => {\n    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n        .filter((value) => value && value.length > 0)\n        .join('-');\n};\nconst eachCacheNameDetail = (fn) => {\n    for (const key of Object.keys(_cacheNameDetails)) {\n        fn(key);\n    }\n};\nexport const cacheNames = {\n    updateDetails: (details) => {\n        eachCacheNameDetail((key) => {\n            if (typeof details[key] === 'string') {\n                _cacheNameDetails[key] = details[key];\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: () => {\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: () => {\n        return _cacheNameDetails.suffix;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n// Callbacks to be executed whenever there's a quota error.\n// Can't change Function type right now.\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst quotaErrorCallbacks = new Set();\nexport { quotaErrorCallbacks };\n"],"names":["self","_","e","exportWorker","handlers","onmessage","async","data","handler","name","Error","result","apply","args","Promise","postMessage","reqid","resolve","reject","message","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","get","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","wrap","set","value","has","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","unwrap","this","storeNames","tx","call","sort","transformCachableValue","done","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","request","promise","success","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","store","index","shift","all","oldTraps","callback","CACHE_OBJECT_STORE","normalizeURL","unNormalizedUrl","url","URL","location","href","hash","CacheTimestampsModel","constructor","cacheName","_db","_cacheName","_upgradeDb","db","objStore","createObjectStore","keyPath","createIndex","unique","_upgradeDbAndDeleteOldDbs","blocked","indexedDB","deleteDatabase","event","oldVersion","deleteDB","setTimestamp","timestamp","entry","id","_getId","getDb","durability","put","getTimestamp","expireEntries","minTimestamp","maxCount","cursor","openCursor","entriesToDelete","entriesNotDeletedCount","push","urlsDeleted","delete","version","upgrade","blocking","terminated","open","openPromise","newVersion","openDB","bind","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_matchOptions","matchOptions","_timestampModel","Date","now","urlsExpired","cache","caches","updateTimestamp","isURLExpired","expireOlderThan","Infinity","registration","scope","Set"],"sourceRoot":""}